'use strict';

var chalk = require('chalk');
var fs = require('fs');
var objectClone = require('clone');
var path = require('path');
var prettyMs = require('pretty-ms');
var rimraf = require('rimraf');
var logger = require('./../../helpers/logger');
var projectDescriptor = require('./../../projectDescriptor');
var cloneRepository = require('./cloneRepository');
var depsInstall = require('./depsInstall');
var generateBundles = require('./generateBundles');
var parseOptions = require('./parseOptions');
var printSelectedPlugins = require('./printSelectedPlugins');
var showUIPrompt = require('./showUIPrompt');

module.exports = function(args, cliOptions) {
  if (!cliOptions.input) {
    logger().info('Creating custom build...\n');
  }

  var now = Date.now();

  var promise = Promise.resolve(objectClone(cliOptions))
    // Clone repository if "input" option was not provided.
    .then(function(options) {
      return options.input ? {options: options} : cloneRepository({options: options});
    })
    // Install dependencies via `npm install` if "input" option was autogenerated by cloning.
    .then(function(data) {
      if (!data.options.hasAutoGeneratedInput) {
        if (!fs.existsSync(path.resolve(data.options.input, 'node_modules'))) {
          throw Error('Required dependencies not found. Please install them by executing `' + chalk.green('npm install') + '` inside ' + chalk.green(data.options.input) + ' directory.');
        }

        return data;
      }

      return depsInstall(data);
    })
    // Collect informaction about project.
    .then(function(data) {
      var project = projectDescriptor(data.options.input);

      data.project = project;

      return data;
    })
    // Show generated UI prompt in terminal if "noUi" option was disabled.
    .then(function(data) {
      if (!data.options.noUi) {
        if (data.options.hasAutoGeneratedInput && logger().transports.caporal.level === 'info') {
          /* eslint-disable no-console */
          console.log(' ');
        }

        return showUIPrompt(data);
      }

      return data;
    })
    // Parse and extend options provided by user.
    .then(function(data) {
      if (!data.options.hasAutoGeneratedInput) {
        logger().info('Creating custom build...\n');
      }

      return parseOptions(data);
    })
    // Make empty line between printed tasks.
    .then(function(data) {
      if (data.options.hasAutoGeneratedInput && logger().transports.caporal.level === 'info') {
        /* eslint-disable no-console */
        console.log(' ');
      }

      return data;
    })
    // Print all found plugins and print theirs statuses.
    .then(function(data) {
      return printSelectedPlugins(data);
    })
    // Generate bundles.
    .then(function(data) {
      return generateBundles(data);
    })
    // Clean project which was automatically cloned and leave project which was provided by user as "input" option.
    .then(function(data) {
      if (data.options.hasAutoGeneratedInput) {
        return new Promise(function(resolve) {
          rimraf(data.options.input, {
            glob: false,
          }, function() {
            resolve(data);
          });
        });
      }

      return data;
    })
    // Print summary.
    .then(function(data) {
      var elapsed = Date.now() - now;
      var message = [
        '',
        'Bundle details:',
        '',
        '  Package: ' + chalk.green(data.project.getName()),
        '  Version: ' + chalk.green(data.options.repositoryTag !== 'master' ? data.options.repositoryTag : data.project.getVersion()),
        '  Built using: ' + chalk.green(data.options.hasAutoGeneratedInput ? data.project.getRepository().url : data.options.input),
        '  Saved into: ' + chalk.green(data.options.outputDir),
        '',
        'Done in ' + chalk.yellow(prettyMs(elapsed)) + '.',
      ];

      logger().info(message.join('\n'));
    });

  return promise;
}
